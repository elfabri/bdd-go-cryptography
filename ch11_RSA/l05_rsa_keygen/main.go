/*
we've been asked at Passly to write
our own RSA from scratch to compare
against the Go standard library's
implementation. Don't worry, it's just
for benchmarking purposes.

First of all, we need to generate
some really big numbers.

  - 2 very large prime numbers are generated,
    we'll call them p and q

  - The first part of the public key
    is generated by multiplying p and q together,
    we'll call this n

Complete the generatePrivateNums and getN functions

  - generatePrivateNums(keysize int) (*big.Int, *big.Int)

Use the provided getBigPrime function to generate
two prime numbers of the given keysize in bits.
Be sure to generate p first, as we're relying
on the determinism of the random number generator.

(Normally we would use the crypto/rand package's rand.Prime
if we wanted true randomness).

  - getN(p, q *big.Int) *big.Int

Use the math/big package's .Mul method to multiply p and q together to get n.
*/
package main

import (
	"math/big"
)

func generatePrivateNums(keysize int) (*big.Int, *big.Int) {
    p, _ := getBigPrime(keysize)
    q, _ := getBigPrime(keysize)
    return p, q
}

// Calculate n = p * q
func getN(p, q *big.Int) *big.Int {
    return p.Mul(p, q)
}
